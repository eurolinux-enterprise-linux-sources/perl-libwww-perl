From 5e2c3cb543def6e5465b85467ee6c5e3856034d0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Petr=20P=C3=ADsa=C5=99?= <ppisar@redhat.com>
Date: Tue, 11 Oct 2011 16:54:08 +0200
Subject: [PATCH] Back-port ssl_opts LWP::UserAgent argument
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This patch adds support for enabling/disabling certificate validation
and host name match between URI and certificate. This can be done by
ssl_opts LWP::UserAgent constructor argument or by environment
variables. Default behaviour is to enable verification.

SSL socket implementation can be selected by environment too. More
advanced IO::Socket::SSL is prefered now.

See <https://bugzilla.redhat.com/show_bug.cgi?id=705044>.
This fixes CVE-2011-0633.

These changes have been ported from version 6 to version 5.833.

Signed-off-by: Petr Písař <ppisar@redhat.com>
---
 lib/LWP/Protocol/https.pm   |  25 ++++++++++-
 lib/LWP/Protocol/https10.pm |  16 +++----
 lib/LWP/UserAgent.pm        | 106 ++++++++++++++++++++++++++++++++++++++++++--
 lib/Net/HTTPS.pm            |  47 ++++++++++++++------
 4 files changed, 168 insertions(+), 26 deletions(-)

diff --git a/lib/LWP/Protocol/https.pm b/lib/LWP/Protocol/https.pm
index 367c8f7..2d0ca90 100644
--- a/lib/LWP/Protocol/https.pm
+++ b/lib/LWP/Protocol/https.pm
@@ -11,6 +11,23 @@ sub socket_type
     return "https";
 }
 
+sub _extra_sock_opts
+{
+    my $self = shift;
+    my %ssl_opts = %{$self->{ua}{ssl_opts} || {}};
+    if (delete $ssl_opts{verify_hostname}) {
+        $ssl_opts{SSL_verify_mode} ||= 1;
+        $ssl_opts{SSL_verifycn_scheme} = 'www';
+    }
+    if ($ssl_opts{SSL_verify_mode}) {
+        unless (exists $ssl_opts{SSL_ca_file} || exists $ssl_opts{SSL_ca_path}) {
+            $ssl_opts{SSL_ca_file} = '/etc/pki/tls/certs/ca-bundle.crt';
+        }
+    }
+    $self->{ssl_opts} = \%ssl_opts;
+    return (%ssl_opts, $self->SUPER::_extra_sock_opts);
+}
+
 sub _check_sock
 {
     my($self, $req, $sock) = @_;
@@ -36,9 +53,13 @@ sub _get_sock_info
 	$res->header("Client-SSL-Cert-Subject" => $cert->subject_name);
 	$res->header("Client-SSL-Cert-Issuer" => $cert->issuer_name);
     }
-    if(! eval { $sock->get_peer_verify }) {
-       $res->header("Client-SSL-Warning" => "Peer certificate not verified");
+    if (!$self->{ssl_opts}{SSL_verify_mode}) {
+        $res->push_header("Client-SSL-Warning" => "Peer certificate not verified");
+    }
+    elsif (!$self->{ssl_opts}{SSL_verifycn_scheme}) {
+	$res->push_header("Client-SSL-Warning" => "Peer hostname match with certificate not verified");
     }
+    $res->header("Client-SSL-Socket-Class" => $Net::HTTPS::SSL_SOCKET_CLASS); 
 }
 
 #-----------------------------------------------------------
diff --git a/lib/LWP/Protocol/https10.pm b/lib/LWP/Protocol/https10.pm
index 662ba76..45a3510 100644
--- a/lib/LWP/Protocol/https10.pm
+++ b/lib/LWP/Protocol/https10.pm
@@ -4,20 +4,20 @@ use strict;
 
 # Figure out which SSL implementation to use
 use vars qw($SSL_CLASS);
-if ($Net::SSL::VERSION) {
-    $SSL_CLASS = "Net::SSL";
-}
-elsif ($IO::Socket::SSL::VERSION) {
+if ($IO::Socket::SSL::VERSION) {
     $SSL_CLASS = "IO::Socket::SSL"; # it was already loaded
 }
+elsif ($Net::SSL::VERSION) {
+    $SSL_CLASS = "Net::SSL";
+}
 else {
-    eval { require Net::SSL; };     # from Crypt-SSLeay
+    eval { require IO::Socket::SSL; };
     if ($@) {
-	require IO::Socket::SSL;
-	$SSL_CLASS = "IO::Socket::SSL";
+        require Net::SSL;     # from Crypt-SSLeay
+	$SSL_CLASS = "Net::SSL";
     }
     else {
-	$SSL_CLASS = "Net::SSL";
+	$SSL_CLASS = "IO::Socket::SSL";
     }
 }
 
diff --git a/lib/LWP/UserAgent.pm b/lib/LWP/UserAgent.pm
index 0f52576..93624d0 100644
--- a/lib/LWP/UserAgent.pm
+++ b/lib/LWP/UserAgent.pm
@@ -40,6 +40,32 @@ sub new
     my $def_headers = delete $cnf{default_headers};
     my $timeout = delete $cnf{timeout};
     $timeout = 3*60 unless defined $timeout;
+    my $ssl_opts = delete $cnf{ssl_opts};
+    unless ($ssl_opts) {
+        # The processing of HTTPS_CA_* below is for compatiblity with Crypt::SSLeay
+        $ssl_opts = {};
+        if (exists $ENV{PERL_LWP_SSL_VERIFY_HOSTNAME}) {
+            $ssl_opts->{verify_hostname} = $ENV{PERL_LWP_SSL_VERIFY_HOSTNAME};
+        }
+        elsif ($ENV{HTTPS_CA_FILE} || $ENV{HTTPS_CA_DIR}) {
+            # Crypt-SSLeay compatiblity (verify peer certificate; but not the hostname)
+            $ssl_opts->{verify_hostname} = 0;
+            $ssl_opts->{SSL_verify_mode} = 1;
+        }
+        else {
+            $ssl_opts->{verify_hostname} = 1;
+        }
+    }
+    unless (exists $ssl_opts->{SSL_ca_file}) {
+        if (my $ca_file = $ENV{PERL_LWP_SSL_CA_FILE} || $ENV{HTTPS_CA_FILE}) {
+            $ssl_opts->{SSL_ca_file} = $ca_file;
+        }
+    }
+    unless (exists $ssl_opts->{SSL_ca_path}) {
+        if (my $ca_path = $ENV{PERL_LWP_SSL_CA_PATH} || $ENV{HTTPS_CA_DIR}) {
+            $ssl_opts->{SSL_ca_path} = $ca_path;
+        }
+    }
     my $use_eval = delete $cnf{use_eval};
     $use_eval = 1 unless defined $use_eval;
     my $parse_head = delete $cnf{parse_head};
@@ -81,6 +107,7 @@ sub new
     my $self = bless {
 		      def_headers  => $def_headers,
 		      timeout      => $timeout,
+		      ssl_opts     => $ssl_opts,
 		      use_eval     => $use_eval,
                       show_progress=> $show_progress,
 		      max_size     => $max_size,
@@ -159,10 +186,10 @@ sub send_request
                 $@ =~ s/ at .* line \d+.*//s;  # remove file/line number
                 $response =  _new_response($request, &HTTP::Status::RC_NOT_IMPLEMENTED, $@);
                 if ($scheme eq "https") {
-                    $response->message($response->message . " (Crypt::SSLeay or IO::Socket::SSL not installed)");
+                    $response->message($response->message . " (IO::Socket::SSL not installed)");
                     $response->content_type("text/plain");
                     $response->content(<<EOT);
-LWP will support https URLs if either Crypt::SSLeay or IO::Socket::SSL
+LWP will support https URLs if either IO::Socket::SSL or Crypt::SSLeay
 is installed. More information at
 <http://search.cpan.org/dist/libwww-perl/README.SSL>.
 EOT
@@ -579,6 +606,31 @@ sub max_size     { shift->_elem('max_size',     @_); }
 sub max_redirect { shift->_elem('max_redirect', @_); }
 sub show_progress{ shift->_elem('show_progress', @_); }
 
+sub ssl_opts {
+    my $self = shift;
+    if (@_ == 1) {
+        my $k = shift;
+        return $self->{ssl_opts}{$k};
+    }
+    if (@_) {
+        my $old;
+        while (@_) {
+            my($k, $v) = splice(@_, 0, 2);
+            $old = $self->{ssl_opts}{$k} unless @_;
+            if (defined $v) {
+                $self->{ssl_opts}{$k} = $v;
+            }
+            else {
+                delete $self->{ssl_opts}{$k};
+            }
+        }
+        %{$self->{ssl_opts}} = (%{$self->{ssl_opts}}, @_);
+        return $old;
+    }
+
+    return keys %{$self->{ssl_opts}};
+}
+
 sub parse_head {
     my $self = shift;
     if (@_) {
@@ -795,7 +847,7 @@ sub clone
     delete $copy->{conn_cache};
 
     # copy any plain arrays and hashes; known not to need recursive copy
-    for my $k (qw(proxy no_proxy requests_redirectable)) {
+    for my $k (qw(proxy no_proxy requests_redirectable ssl_opts)) {
         next unless $copy->{$k};
         if (ref($copy->{$k}) eq "ARRAY") {
             $copy->{$k} = [ @{$copy->{$k}} ];
@@ -1270,6 +1322,54 @@ is observed for C<timeout> seconds.  This means that the time it takes
 for the complete transaction and the request() method to actually
 return might be longer.
 
+=item $ua->ssl_opts
+
+=item $ua->ssl_opts( $key )
+
+=item $ua->ssl_opts( $key => $value )
+
+Get/set the options for SSL connections.  Without argument return the list
+of options keys currently set.  With a single argument return the current
+value for the given option.  With 2 arguments set the option value and return
+the old.  Setting an option to the value C<undef> removes this option.
+
+The options that LWP relates to are:
+
+=over
+
+=item C<verify_hostname> => $bool
+
+When TRUE LWP will for secure protocol schemes ensure it connects to servers
+that have a valid certificate matching the expected hostname.  If FALSE no
+checks are made and you can't be sure that you communicate with the expected peer.
+The no checks behaviour was the default for libwww-perl-5.837 and earlier releases.
+
+This option is initialized from the L<PERL_LWP_SSL_VERIFY_HOSTNAME> environment
+variable.  If this envirionment variable isn't set; then C<verify_hostname>
+defaults to 1.
+
+=item C<SSL_ca_file> => $path
+
+The path to a file containing Certificate Authority certificates.
+A default setting for this option is provided by checking the environment
+variables C<PERL_LWP_SSL_CA_FILE> and C<HTTPS_CA_FILE> in order. Last resort
+value is built-in value F</etc/pki/tls/certs/ca-bundle.crt>.
+
+=item C<SSL_ca_path> => $path
+
+The path to a directory containing files containing Certificate Authority
+certificates.
+A default setting for this option is provided by checking the environment
+variables C<PERL_LWP_SSL_CA_PATH> and C<HTTPS_CA_DIR> in order.
+
+=back
+
+Other options can be set and are processed directly by the SSL Socket implementation
+in use.  See L<IO::Socket::SSL> or L<Net::SSL> for details.
+
+SSL Socket implementation can be selected by environment variable
+C<PERL_NET_HTTPS_SSL_SOCKET_CLASS>. L<IO::Socket::SSL> is preferred by default.
+
 =back
 
 =head2 Proxy attributes
diff --git a/lib/Net/HTTPS.pm b/lib/Net/HTTPS.pm
index bfed714..750cf42 100644
--- a/lib/Net/HTTPS.pm
+++ b/lib/Net/HTTPS.pm
@@ -9,27 +9,34 @@ $VERSION = "5.819";
 if ($SSL_SOCKET_CLASS) {
     # somebody already set it
 }
-elsif ($Net::SSL::VERSION) {
-    $SSL_SOCKET_CLASS = "Net::SSL";
+elsif ($SSL_SOCKET_CLASS = $ENV{PERL_NET_HTTPS_SSL_SOCKET_CLASS}) {
+    unless ($SSL_SOCKET_CLASS =~ /^(IO::Socket::SSL|Net::SSL)\z/) {
+        die "Bad socket class [$SSL_SOCKET_CLASS]";
+    }
+    eval "require $SSL_SOCKET_CLASS";
+    die $@ if $@;
 }
 elsif ($IO::Socket::SSL::VERSION) {
     $SSL_SOCKET_CLASS = "IO::Socket::SSL"; # it was already loaded
 }
+elsif ($Net::SSL::VERSION) {
+    $SSL_SOCKET_CLASS = "Net::SSL";
+}
 else {
-    eval { require Net::SSL; };     # from Crypt-SSLeay
+    eval { require IO::Socket::SSL; };
     if ($@) {
-	my $old_errsv = $@;
-	eval {
-	    require IO::Socket::SSL;
-	};
-	if ($@) {
-	    $old_errsv =~ s/\s\(\@INC contains:.*\)/)/g;
-	    die $old_errsv . $@;
-	}
-	$SSL_SOCKET_CLASS = "IO::Socket::SSL";
+        my $old_errsv = $@;
+        eval {
+            require Net::SSL;  # from Crypt-SSLeay
+        };
+        if ($@) {
+            $old_errsv =~ s/\s\(\@INC contains:.*\)/)/g;
+            die $old_errsv . $@;
+        }
+        $SSL_SOCKET_CLASS = "Net::SSL";
     }
     else {
-	$SSL_SOCKET_CLASS = "Net::SSL";
+        $SSL_SOCKET_CLASS = "IO::Socket::SSL";
     }
 }
 
@@ -44,6 +51,20 @@ sub configure {
 
 sub http_connect {
     my($self, $cnf) = @_;
+    if ($self->isa("Net::SSL")) {
+        if ($cnf->{SSL_verify_mode}) {
+            if (my $f = $cnf->{SSL_ca_file}) {
+                $ENV{HTTPS_CA_FILE} = $f;
+            }
+            if (my $f = $cnf->{SSL_ca_path}) {
+                $ENV{HTTPS_CA_DIR} = $f;
+            }
+        }
+        if ($cnf->{SSL_verifycn_scheme}) {
+            $@ = "Net::SSL from Crypt-SSLeay can't verify hostnames; either install IO::Socket::SSL or turn off verification by setting the PERL_LWP_SSL_VERIFY_HOSTNAME environment variable to 0";
+            return undef;
+        }
+    }
     $self->SUPER::configure($cnf);
 }
 
-- 
2.5.0

